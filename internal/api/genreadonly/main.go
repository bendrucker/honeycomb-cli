package main

import (
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"
	"text/template"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintln(os.Stderr, "usage: genreadonly <api.json> <output.go>")
		os.Exit(1)
	}

	data, err := os.ReadFile(os.Args[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "reading spec: %v\n", err)
		os.Exit(1)
	}

	var spec map[string]any
	if err := json.Unmarshal(data, &spec); err != nil {
		fmt.Fprintf(os.Stderr, "parsing spec: %v\n", err)
		os.Exit(1)
	}

	schemas := navigateMap(spec, "components", "schemas")
	if schemas == nil {
		fmt.Fprintln(os.Stderr, "no components.schemas found")
		os.Exit(1)
	}

	result := map[string][]string{}
	for name, schema := range schemas {
		s, ok := schema.(map[string]any)
		if !ok {
			continue
		}
		fields := collectReadOnly(schemas, s)
		if len(fields) > 0 {
			fields = dedup(fields)
			result[name] = fields
		}
	}

	names := make([]string, 0, len(result))
	for name := range result {
		names = append(names, name)
	}
	sort.Strings(names)

	type entry struct {
		Key    string
		Values string
	}

	entries := make([]entry, len(names))
	for i, name := range names {
		fields := result[name]
		parts := make([]string, len(fields))
		for j, f := range fields {
			parts[j] = fmt.Sprintf("%q: true", f)
		}
		entries[i] = entry{
			Key:    fmt.Sprintf("%q", name),
			Values: strings.Join(parts, ", "),
		}
	}

	var buf strings.Builder
	if err := outputTmpl.Execute(&buf, entries); err != nil {
		fmt.Fprintf(os.Stderr, "executing template: %v\n", err)
		os.Exit(1)
	}

	formatted, err := format.Source([]byte(buf.String()))
	if err != nil {
		fmt.Fprintf(os.Stderr, "formatting output: %v\n", err)
		os.Exit(1)
	}

	if err := os.WriteFile(os.Args[2], formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "writing output: %v\n", err)
		os.Exit(1)
	}
}

func collectReadOnly(schemas map[string]any, schema map[string]any) []string {
	var fields []string

	if props, ok := schema["properties"].(map[string]any); ok {
		for name, prop := range props {
			p, ok := prop.(map[string]any)
			if !ok {
				continue
			}
			if ro, ok := p["readOnly"].(bool); ok && ro {
				fields = append(fields, name)
			}
		}
	}

	if allOf, ok := schema["allOf"].([]any); ok {
		for _, item := range allOf {
			m, ok := item.(map[string]any)
			if !ok {
				continue
			}
			if ref, ok := m["$ref"].(string); ok {
				refName := refToName(ref)
				if refSchema, ok := schemas[refName].(map[string]any); ok {
					fields = append(fields, collectReadOnly(schemas, refSchema)...)
				}
			} else {
				fields = append(fields, collectReadOnly(schemas, m)...)
			}
		}
	}

	return fields
}

func dedup(s []string) []string {
	sort.Strings(s)
	out := s[:0]
	for i, v := range s {
		if i == 0 || v != s[i-1] {
			out = append(out, v)
		}
	}
	return out
}

func refToName(ref string) string {
	parts := strings.Split(ref, "/")
	return parts[len(parts)-1]
}

var outputTmpl = template.Must(template.New("readonly").Parse(
	`// Code generated by genreadonly; DO NOT EDIT.
package api

var readOnlyFields = map[string]map[string]bool{
{{- range .}}
	{{.Key}}: { {{- .Values -}} },
{{- end}}
}
`))

func navigateMap(m map[string]any, keys ...string) map[string]any {
	current := m
	for _, key := range keys {
		next, ok := current[key].(map[string]any)
		if !ok {
			return nil
		}
		current = next
	}
	return current
}
