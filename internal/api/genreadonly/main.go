package main

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"
)

func main() {
	if len(os.Args) < 3 {
		fmt.Fprintln(os.Stderr, "usage: genreadonly <api.json> <output.go>")
		os.Exit(1)
	}

	data, err := os.ReadFile(os.Args[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "reading spec: %v\n", err)
		os.Exit(1)
	}

	var spec map[string]any
	if err := json.Unmarshal(data, &spec); err != nil {
		fmt.Fprintf(os.Stderr, "parsing spec: %v\n", err)
		os.Exit(1)
	}

	schemas := navigateMap(spec, "components", "schemas")
	if schemas == nil {
		fmt.Fprintln(os.Stderr, "no components.schemas found")
		os.Exit(1)
	}

	result := map[string][]string{}
	for name, schema := range schemas {
		s, ok := schema.(map[string]any)
		if !ok {
			continue
		}
		fields := collectReadOnly(schemas, s)
		if len(fields) > 0 {
			fields = dedup(fields)
			result[name] = fields
		}
	}

	names := make([]string, 0, len(result))
	for name := range result {
		names = append(names, name)
	}
	sort.Strings(names)

	var buf strings.Builder
	buf.WriteString("// Code generated by genreadonly; DO NOT EDIT.\n")
	buf.WriteString("package api\n\n")
	buf.WriteString("var readOnlyFields = map[string]map[string]bool{\n")
	for _, name := range names {
		fields := result[name]
		parts := make([]string, len(fields))
		for i, f := range fields {
			parts[i] = fmt.Sprintf("%q: true", f)
		}
		fmt.Fprintf(&buf, "\t%q: {%s},\n", name, strings.Join(parts, ", "))
	}
	buf.WriteString("}\n")

	if err := os.WriteFile(os.Args[2], []byte(buf.String()), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "writing output: %v\n", err)
		os.Exit(1)
	}
}

func collectReadOnly(schemas map[string]any, schema map[string]any) []string {
	var fields []string

	if props, ok := schema["properties"].(map[string]any); ok {
		for name, prop := range props {
			p, ok := prop.(map[string]any)
			if !ok {
				continue
			}
			if ro, ok := p["readOnly"].(bool); ok && ro {
				fields = append(fields, name)
			}
		}
	}

	if allOf, ok := schema["allOf"].([]any); ok {
		for _, item := range allOf {
			m, ok := item.(map[string]any)
			if !ok {
				continue
			}
			if ref, ok := m["$ref"].(string); ok {
				refName := refToName(ref)
				if refSchema, ok := schemas[refName].(map[string]any); ok {
					fields = append(fields, collectReadOnly(schemas, refSchema)...)
				}
			} else {
				fields = append(fields, collectReadOnly(schemas, m)...)
			}
		}
	}

	return fields
}

func dedup(s []string) []string {
	sort.Strings(s)
	out := s[:0]
	for i, v := range s {
		if i == 0 || v != s[i-1] {
			out = append(out, v)
		}
	}
	return out
}

func refToName(ref string) string {
	parts := strings.Split(ref, "/")
	return parts[len(parts)-1]
}

func navigateMap(m map[string]any, keys ...string) map[string]any {
	current := m
	for _, key := range keys {
		next, ok := current[key].(map[string]any)
		if !ok {
			return nil
		}
		current = next
	}
	return current
}
